def bfs(G, v):                      # 그래프 G, 탐색 시작점 v
    visited = [0]*(n+1)             # n : 정점의 개수
    queue = []                      # 큐 생성
    queue.append(v)                 # 시작점 v를 큐에 삽입

    while queue :                   # 큐가 비어있지 않은 경우
        t = queue.pop(0)            # 큐의 첫번째 원소 반환
        if not visited[t]:          # 방문디지 않은 곳이라면
            visited[t] = True       # 방문한 것으로 표시
            visited(t)                # 정점 t에서 할 일
            for i in G[t]:          # 정점 t에서 할 일
                if not visited[i]:  # 방문되지 않은 곳이라면
                    queue.append(i) # 큐에 넣기

# 또 써보면서 다시 생각해보자
# 근데 한글부터 써볼까?
# BFS가 뭐냐? => 그래프를 탐색할건데 뿌리 노드에서 인접한 정점부터 방문하는 방식. 그래서 깊이보다 너비가 우선되는 너비 우선 탐색 방식
# 그럼 어떻게 알고리즘을 구성해야할까?
# 현재 노드에서 이어지는 노드들 인접 노드들을 확인하고, 그들을 탐색하자.
# 이때, 방문한 노드에 대해서는 방문표시를 해주자.
# 현재 노드에 대해서 인접한 노드들을 모두 방문했다면? 이건 어떻게 알지? 인접 노드 리스트에서 하나씩 팝해주면 되나?


# 그래프와 탐색 시작점을 받아오자 G, V
# 방문 체크 리스트를 만들자
# 이때, 정점의 개수 + 1 한 만큼 리스트를 만들어서 인덱스 번호와 노드 번호를 일치시키자
# bfs는 큐 방식을 기반으로 한다. 큐 방식은 FIFO 선입선출 방식의 메모리.
# 큐 리스트 만들어주자.
# 지금부터는 반복문. 큐가 텅 빌 때까지 돌자.
# 선입선출 방식이니까 큐의 첫 번째 원소 반환
# 방문하지 않은 곳이면
# 방문하고 방문 표시 해주자
# 현재 방문한 노드의 인접 노드들을 확인하고 방문표시가 없다면 큐에 넣어주자
# 반복 돌겠지?